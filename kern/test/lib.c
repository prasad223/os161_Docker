#include <kern/secret.h>
#include <types.h>
#include <thread.h>
#include <test.h>
#include <lib.h>
#include <kern/secure.h>

/*
 * Common success function for kernel tests. If SECRET_TESTING is defined,
 * ksecprintf will compute the hmac/sha256 hash of any message using the
 * shared secret and a random salt value. The (secure) server also knows
 * the secret and can verify the message was generated by a trusted source.
 * The salt value prevents against replay attacks.
 */
int
success(bool status, const char * secret, const char * name) {
	if (status == SUCCESS) {
		return ksecprintf(secret, "SUCCESS", name);
	} else {
		return ksecprintf(secret, "FAIL", name);
	}
}

#ifndef SECRET_TESTING

int
ksecprintf(const char * secret, const char * msg, const char * name)
{
	(void)secret;
	return kprintf("%s: %s\n", name, msg);
}

#else

int
ksecprintf(const char * secret, const char * msg, const char * name)
{
	char *hash, *salt, *fullmsg;
	int res;
	size_t len;

	hash = salt = fullmsg = NULL;

	// test161 expects "name: msg"
	len = strlen(name) + strlen(msg) + 3;	// +3 for " :" and null terminator
	fullmsg = (char *)kmalloc(len);
	KASSERT(fullmsg != NULL);
	snprintf(fullmsg, len, "%s: %s", name, msg);

	res = hmac_salted(fullmsg, len-1, secret, strlen(secret), &hash, &salt);
	KASSERT(res == 0);

	res = kprintf("(%s, %s, %s, %s: %s)\n", name, hash, salt, name, msg);

	kfree(hash);
	kfree(salt);
	kfree(fullmsg);

	return res;
}

#endif

/*
 * Helper functions used by testing and problem driver code
 * to establish better mixtures of threads.
 */

void
random_yielder(uint32_t max_yield_count)
{
	uint32_t i;
	for (i = 0; i < random() % max_yield_count; i++) {
		thread_yield();
	}
}

void
random_spinner(uint32_t max_spin_count)
{
	uint32_t i;
	volatile int spin;
	for (i = 0; i < random() % max_spin_count; i++) {
		spin += i;
	}
}
